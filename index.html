<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Live ASCII Text</title>
  <style>
    :root{--bg:#0f0f10;--fg:#e5e7eb}
    html,body{height:100%;margin:0}
    body{background:var(--bg);color:var(--fg);font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;overflow:hidden}

    /* ASCII-Bühne (einzige sichtbare Schrift) */
    pre#ascii{position:fixed;inset:0;margin:0;white-space:pre;text-align:center;line-height:1;font-family:inherit;font-variant-ligatures:none;letter-spacing:0;user-select:none}

    /* Unsichtbares Eingabefeld */
    .ghost-input{position:fixed;inset:0;opacity:0;border:0;outline:0}

    /* Animations-Canvas */
    canvas#anim{position:fixed;inset:0;display:none}

    /* Legende unten links */
    .legend{position:fixed;left:12px;bottom:10px;font-size:12px;opacity:.9;color:#9ca3af;user-select:none;line-height:1.35}
  </style>
</head>
<body>
  <input id="hidden" class="ghost-input" autocomplete="off" spellcheck="false" maxlength="20" />
  <pre id="ascii"></pre>
  <div id="legend" class="legend"></div>
  <canvas id="anim"></canvas>
  <canvas id="work" style="display:none"></canvas>

  <script>
    const hidden = document.getElementById('hidden');
    const ascii  = document.getElementById('ascii');
    const work   = document.getElementById('work');
    const anim   = document.getElementById('anim');
    const legend = document.getElementById('legend');
    const ctx    = work.getContext('2d');
    const actx   = anim.getContext('2d');

    // Mobile-Erkennung
    const isMobile = (matchMedia('(pointer: coarse)').matches && matchMedia('(hover: none)').matches) || ('ontouchstart' in window);
    const allowMouseFollow = !isMobile; // Maus folgt nur am Desktop

    // Zeichen von hell -> dunkel (Backslashes korrekt escaped)
    const CHARSET = " .'`^:,;Il!i><~+_-?][}{1)(|\\/tfjrxnuvczXYUJCLQ0OZmwqpdbkhao*#MW&8%B@$";
    const MAX_LEN = 20;

    // Zustände
    let lastGrid = [];                 // {ci, ri, ch, color}
    let cellSize = 8;
    let gridCols = 0, gridRows = 0;    // Spalten/Zeilen des ASCII-Layouts
    let isAnimating = false;

    // Maus-/Finger-Collider (halber Radius vs. vorher)
    const mouse = { x: 0, y: 0, r: 40, active: false };
    function updateMouseRadius(){ mouse.r = Math.max(20, Math.round(cellSize * 2.5)); }

    // DESKTOP: Maus folgt (optional). MOBILE: Position bleibt dort, wo getippt wurde
    window.addEventListener('pointermove', (e)=>{ if(!allowMouseFollow) return; mouse.x = e.clientX; mouse.y = e.clientY; mouse.active = true; });
    window.addEventListener('pointerleave', ()=>{ if(!allowMouseFollow) mouse.active = false; });

    // MOBILE: Taps -> Single: Drop, Double: Delete
    let lastTapTime = 0, lastTapX = 0, lastTapY = 0;
    function handleTap(x,y){
      const now = performance.now();
      const dt = now - lastTapTime;
      const dist = Math.hypot(x-lastTapX, y-lastTapY);
      lastTapTime = now; lastTapX = x; lastTapY = y;
      if(dt < 320 && dist < 48){ // Double Tap -> Enter/Delete
        hidden.value = '';
        if(!isAnimating) renderASCII('');
        return;
      }
      // Single Tap -> Finger-Maus positionieren (statisch) und Fallen auslösen
      mouse.x = x; mouse.y = y; mouse.active = true;
      if(hidden.value && !isAnimating) triggerFall();
    }

    // Pointer-Down: Desktop (nur Cursor setzen), Mobile (Tap-Handling)
    window.addEventListener('pointerdown', (e)=>{
      if(isMobile){ handleTap(e.clientX, e.clientY); }
      else { mouse.x = e.clientX; mouse.y = e.clientY; mouse.active = true; }
    });

    function computeCellSize(W){
      const targetCols = Math.max(80, Math.min(220, Math.round(W/8)));
      return Math.max(4, Math.floor(W/targetCols));
    }

    function renderASCII(text){
      const W = work.width  = Math.round(window.innerWidth);
      const H = work.height = Math.round(window.innerHeight);

      // Hintergrund
      ctx.clearRect(0,0,W,H);
      ctx.fillStyle = '#000';
      ctx.fillRect(0,0,W,H);

      // Großes Wort als Grundlage NUR im Hidden-Canvas zeichnen (sehr fette Schrift)
      const safe = (text||'').slice(0, MAX_LEN).replace(/\n/g,' ');
      if (text && text.length > MAX_LEN) hidden.value = safe; // Hard-Limit auch am Input
      const len = safe.length || 1;

      // Startgröße und Breitenanpassung (bis 20 Zeichen wird proportional kleiner)
      const base0 = Math.min(W, H) * 0.6;
      ctx.textBaseline = 'middle';
      ctx.textAlign = 'center';
      // Sehr fette Fonts bevorzugen
      ctx.font = `900 ${base0}px Impact, 'Arial Black', system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;
      const em0 = ctx.measureText('M').width || (base0*0.6);
      const scaleW = Math.min(1, (W*0.9) / (em0 * len));
      const base  = Math.max(16, base0 * scaleW);
      ctx.font = `900 ${base}px Impact, 'Arial Black', system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;
      const em = ctx.measureText('M').width || (base*0.6);

      const minGray = 60; // erster Buchstabe sichtbar
      for(let i=0;i<len;i++){
        const ch = safe[i] || '';
        const g  = Math.round(minGray + ((len>1? i/(len-1) : 1) * (255 - minGray)));
        ctx.fillStyle = `rgb(${g},${g},${g})`;
        const x = (W/2) - (em*((len-1)/2 - i));
        // dicker zeichnen: leicht versetzte Mehrfachfüllung
        ctx.fillText(ch, x, H/2);
        ctx.fillText(ch, x+1, H/2);
        ctx.fillText(ch, x-1, H/2);
        ctx.fillText(ch, x, H/2+1);
        ctx.fillText(ch, x, H/2-1);
      }

      // ASCII-Sampling
      cellSize = computeCellSize(W);
      updateMouseRadius();
      ascii.style.fontSize  = cellSize + 'px';
      ascii.style.lineHeight= cellSize + 'px';

      const data = ctx.getImageData(0,0,W,H).data;
      lastGrid = [];
      gridCols = Math.floor(W / cellSize);
      gridRows = Math.floor(H / cellSize);

      let out='';
      for(let y=0;y<gridRows;y++){
        for(let x=0;x<gridCols;x++){
          const px = x*cellSize;
          const py = y*cellSize;
          const idx=(py*W + px)*4;
          const r=data[idx], g=data[idx+1], b=data[idx+2];
          const lum = (0.2126*r + 0.7152*g + 0.0722*b);
          const ch = CHARSET[Math.floor((lum/255)*(CHARSET.length-1))];
          out += `<span style="color:rgb(${r},${g},${b})">${ch}</span>`;
          lastGrid.push({ci:x, ri:y, ch, color:`rgb(${r},${g},${b})`});
        }
        out += "\n";
      }
      ascii.innerHTML = out;
    }

    function update(){ renderASCII(hidden.value); }

    // Tastatur (Desktop) + Eingabe
    hidden.addEventListener('keydown', (e)=>{
      if(e.key==='Enter') { e.preventDefault(); hidden.value=''; update(); }
      if(!isMobile && e.key==='ArrowDown'){ e.preventDefault(); triggerFall(); }
    });
    hidden.addEventListener('input', ()=>{ if(!isAnimating) update(); });

    // Nur am Desktop automatisch fokussieren
    const refocus=()=>{ if(!isMobile) hidden.focus(); };
    window.addEventListener('click', refocus);
    window.addEventListener('load', ()=>{ refocus(); renderASCII(''); updateLegend(); });
    window.addEventListener('resize', ()=>{ if(!isAnimating) renderASCII(hidden.value); });

    function updateLegend(){
      if(isMobile){
        legend.innerHTML = 'Type something!<br>Single Tap: Drop it like it\'s hot.<br>Double Tap: Delete Text';
      } else {
        legend.innerHTML = 'Type something!<br>Enter: Delete Text<br>↓: Drop it like it\'s hot!';
      }
    }

    // --- Animation exakt aus dem ASCII-Raster + Maus/Finger-Collider ---
    function triggerFall(){
      if(isAnimating || lastGrid.length===0) return;
      isAnimating = true;
      ascii.style.display = 'none';
      anim.width  = window.innerWidth;
      anim.height = window.innerHeight;
      anim.style.display = 'block';

      const floor = anim.height - cellSize * 0.5;
      const G = 2000;

      // gleiche Typografie wie im <pre>
      actx.font = `${cellSize}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace`;
      actx.textAlign = 'center';
      actx.textBaseline = 'middle';
      const charW = actx.measureText('M').width; // reale Zeichenbreite
      const charH = cellSize;
      const left  = (anim.width  - gridCols*charW) / 2;
      const top   = (anim.height - gridRows*charH) / 2;

      const parts = lastGrid.map(p=>({
        x: left + (p.ci + 0.5)*charW,
        y: top  + (p.ri + 0.5)*charH,
        vx:(Math.random()-0.5)*30,
        vy:(Math.random()-0.5)*20,
        ch:p.ch, color:p.color,
        gScale: 0.98 + Math.random()*0.04,
        air:    0.994 + Math.random()*0.004,
        rest:   0.48 + Math.random()*0.18,
        fric:   0.975 + Math.random()*0.025,
        settleV: 50 + Math.random()*25,
        maxBounces: 2 + Math.round(Math.random()),
        bounces:0, settled:false
      }));

      let last = performance.now();
      (function frame(now){
        const dt = Math.min(0.033, (now-last)/1000);
        last = now;
        actx.clearRect(0,0,anim.width,anim.height);

        let allSettled = true;
        for(const p of parts){
          if(!p.settled){
            // Integration
            p.vy += (G*p.gScale)*dt;
            p.vx *= p.air;
            p.x  += p.vx*dt;
            p.y  += p.vy*dt;

            // Kreis-Collider (Maus/Finger)
            if(mouse.active){
              const dx = p.x - mouse.x;
              const dy = p.y - mouse.y;
              const dist = Math.hypot(dx, dy);
              const R = mouse.r;
              if(dist < R){
                const nx = (dist>0? dx/dist : 1);
                const ny = (dist>0? dy/dist : 0);
                const overlap = (R - dist) + 0.5;
                p.x += nx * overlap;
                p.y += ny * overlap;
                const vn = p.vx*nx + p.vy*ny;
                const e = 0.6; // Elastizität
                if(vn < 0){
                  p.vx -= (1+e) * vn * nx;
                  p.vy -= (1+e) * vn * ny;
                }
                p.vx *= 0.98; p.vy *= 0.98;
              }
            }

            // Boden-Kollision
            if(p.y > floor){
              p.y = floor;
              p.vy = -p.vy * p.rest;
              p.vx *= p.fric;
              p.vx += (Math.random()-0.5)*24;
              p.vy += (Math.random()-0.5)*12;
              p.bounces++;
              if(Math.abs(p.vy) < p.settleV || p.bounces >= p.maxBounces){ p.vy = 0; p.settled = true; }
            }
            // Seiten-Kollisionen
            if(p.x < charW*0.5){ p.x = charW*0.5; p.vx = -p.vx * (0.55 + Math.random()*0.25); }
            if(p.x > anim.width - charW*0.5){ p.x = anim.width - charW*0.5; p.vx = -p.vx * (0.55 + Math.random()*0.25); }
          }
          if(!p.settled) allSettled = false;
          actx.fillStyle = p.color;
          actx.fillText(p.ch, p.x, p.y);
        }

        if(allSettled){
          isAnimating = false;
          anim.style.display = 'none';
          ascii.style.display = 'block';
          renderASCII(hidden.value);
        } else {
          requestAnimationFrame(frame);
        }
      })(last);
    }
  </script>
</body>
</html>
