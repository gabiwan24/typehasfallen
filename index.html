<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Live ASCII Text</title>
  <style>
    :root{--bg:#0f0f10;--fg:#e5e7eb;--panel:#151517;--panelBorder:#2a2a2e}
    html,body{height:100%;margin:0}
    body{background:var(--bg);color:var(--fg);font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;overflow:hidden;user-select:none}

    /* ASCII-Bühne (einzige sichtbare Schrift) */
    pre#ascii{position:fixed;inset:0;margin:0;white-space:pre;text-align:center;line-height:1;font-family:inherit;font-variant-ligatures:none;letter-spacing:0}

    /* Unsichtbares Vollbild-Eingabefeld (für Tastatur) */
    .ghost-input{position:fixed;inset:0;opacity:0;border:0;outline:0}

    /* Animations-Canvas */
    canvas#anim{position:fixed;inset:0;display:none}

    /* Legende unten links */
    .legend{position:fixed;left:12px;bottom:10px;font-size:12px;opacity:.9;color:#9ca3af;line-height:1.35}

    /* Controls (Slider) oben rechts */
    .controls{position:fixed;right:12px;top:12px;z-index:20;display:flex;gap:.6rem;align-items:center;background:var(--panel);border:1px solid var(--panelBorder);border-radius:10px;padding:8px 10px;box-shadow:0 6px 20px rgba(0,0,0,.25)}
    .controls label{font-size:12px;color:#a1a1aa}
    .controls output{min-width:64px;text-align:right;display:inline-block;font-size:12px;color:#e5e7eb}
    .controls input[type="range"]{width:180px}
  </style>
</head>
<body>
  <input id="hidden" class="ghost-input" autocomplete="off" spellcheck="false" maxlength="20" />
  <pre id="ascii"></pre>
  <div id="legend" class="legend">Type something!<br>Enter: Delete Text<br>↓: Drop it like it's hot!</div>
  <div id="controls" class="controls">
    <label>Gravity</label>
    <input id="gSlider" type="range" min="-0.002" max="2" step="0.001" value="1" />
    <output id="gLabel">1.00× g</output>
  </div>
  <canvas id="anim"></canvas>
  <canvas id="work" style="display:none"></canvas>

  <script>
    const hidden = document.getElementById('hidden');
    const ascii  = document.getElementById('ascii');
    const work   = document.getElementById('work');
    const anim   = document.getElementById('anim');
    const legend = document.getElementById('legend');
    const controls= document.getElementById('controls');
    const gSlider = document.getElementById('gSlider');
    const gLabel  = document.getElementById('gLabel');
    const ctx    = work.getContext('2d');
    const actx   = anim.getContext('2d');

    // Zeichen von hell -> dunkel
    const CHARSET = " .'`^:,;Il!i><~+_-?][}{1)(|\\/tfjrxnuvczXYUJCLQ0OZmwqpdbkhao*#MW&8%B@$";
    const MAX_LEN = 20;

    // Zufällige, aber stabile (pro Zeichen) Grauverläufe
    function hashCode(str){
      let h = 2166136261 >>> 0; // FNV-1a
      for(let i=0;i<str.length;i++){
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return h >>> 0;
    }
    function xorshift32(seed){
      let s = (seed|0) || 1;
      return function(){
        s ^= s<<13; s ^= s>>>17; s ^= s<<5;
        return ((s>>>0)/4294967296);
      }
    }
    function makeGrayGrad(ctx, cx, cy, w, h, rnd){
      const angle = rnd() * Math.PI * 2;
      const r = Math.max(w, h) * 0.75;
      const x0 = cx - Math.cos(angle)*r, y0 = cy - Math.sin(angle)*r;
      const x1 = cx + Math.cos(angle)*r, y1 = cy + Math.sin(angle)*r;
      const gA = 60 + Math.floor(rnd()*180);
      const gB = 60 + Math.floor(rnd()*180);
      const grad = ctx.createLinearGradient(x0,y0,x1,y1);
      grad.addColorStop(0, `rgb(${gA},${gA},${gA})`);
      if(rnd()>0.5){
        const pos = 0.2 + rnd()*0.6;
        const gM = 60 + Math.floor(rnd()*180);
        grad.addColorStop(pos, `rgb(${gM},${gM},${gM})`);
      }
      grad.addColorStop(1, `rgb(${gB},${gB},${gB})`);
      return grad;
    }

    // Zustände
    let lastGrid = [];                 // {ci, ri, ch, color}
    let cellSize = 8;
    let gridCols = 0, gridRows = 0;    // Spalten/Zeilen des ASCII-Layouts
    let isAnimating = false;

    // Gravitation (Slider): Basis 1.0× g
    const gBase = 2000; // px/s^2, entspricht "1 g" in unserer Welt
    let gravityScale = 1.0; // wird vom Slider gesteuert
    function updateGravity(){
      gravityScale = parseFloat(gSlider.value);
      const decimals = Math.abs(gravityScale) < 0.1 ? 3 : 2;
      gLabel.textContent = gravityScale.toFixed(decimals) + '× g';
    }
    gSlider.addEventListener('input', updateGravity);
    gSlider.addEventListener('change', updateGravity);
    updateGravity();

    // Maus-Collider
    const mouse = { x: 0, y: 0, r: 40, active: false };
    function updateMouseRadius(){ mouse.r = Math.max(20, Math.round(cellSize * 2.5)); }
    window.addEventListener('pointermove', (e)=>{ mouse.x = e.clientX; mouse.y = e.clientY; mouse.active = true; });
    window.addEventListener('pointerdown', (e)=>{ mouse.x = e.clientX; mouse.y = e.clientY; mouse.active = true; });
    window.addEventListener('pointerleave', ()=>{ mouse.active = false; });

    // Verhindere, dass Slider-Klicks das Input sofort fokussieren
    ['pointerdown','click'].forEach(evt=>{
      controls.addEventListener(evt, ev=>ev.stopPropagation());
    });

    function computeCellSize(W){
      const targetCols = Math.max(80, Math.min(220, Math.round(W/8)));
      return Math.max(4, Math.floor(W/targetCols));
    }

    function renderASCII(text){
      const W = work.width  = Math.round(window.innerWidth);
      const H = work.height = Math.round(window.innerHeight);

      // Hintergrund
      ctx.clearRect(0,0,W,H);
      ctx.fillStyle = '#000';
      ctx.fillRect(0,0,W,H);

      // Großes Wort als Grundlage NUR im Hidden-Canvas zeichnen (sehr fette Schrift)
      const safe = (text||'').slice(0, MAX_LEN).replace(/\n/g,' ');
      if (text && text.length > MAX_LEN) hidden.value = safe; // Hard-Limit auch am Input
      const len = safe.length || 1;

      // Startgröße und Breitenanpassung (bis 20 Zeichen wird proportional kleiner)
      const base0 = Math.min(W, H) * 0.6;
      ctx.textBaseline = 'middle';
      ctx.textAlign = 'center';
      // Sehr fette Fonts bevorzugen
      ctx.font = `900 ${base0}px Impact, 'Arial Black', system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;
      const em0 = ctx.measureText('M').width || (base0*0.6);
      const scaleW = Math.min(1, (W*0.9) / (em0 * len));
      const base  = Math.max(16, base0 * scaleW);
      ctx.font = `900 ${base}px Impact, 'Arial Black', system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;
      const em = ctx.measureText('M').width || (base*0.6);

      for(let i=0;i<len;i++){
        const ch = safe[i] || '';
        const x = (W/2) - (em*((len-1)/2 - i));
        const key = ch + '#' + i;            // stabiler Schlüssel pro Zeichen
        const rnd = xorshift32(hashCode(key));
        const wch = ctx.measureText(ch).width || em;
        ctx.fillStyle = makeGrayGrad(ctx, x, H/2, wch, base, rnd);
        // dicker zeichnen: leicht versetzte Mehrfachfüllung
        ctx.fillText(ch, x, H/2);
        ctx.fillText(ch, x+1, H/2);
        ctx.fillText(ch, x-1, H/2);
        ctx.fillText(ch, x, H/2+1);
        ctx.fillText(ch, x, H/2-1);
      }

      // ASCII-Sampling
      cellSize = computeCellSize(W);
      updateMouseRadius();
      ascii.style.fontSize  = cellSize + 'px';
      ascii.style.lineHeight= cellSize + 'px';

      const data = ctx.getImageData(0,0,W,H).data;
      lastGrid = [];
      gridCols = Math.floor(W / cellSize);
      gridRows = Math.floor(H / cellSize);

      let out='';
      for(let y=0;y<gridRows;y++){
        for(let x=0;x<gridCols;x++){
          const px = x*cellSize;
          const py = y*cellSize;
          const idx=(py*W + px)*4;
          const r=data[idx], g=data[idx+1], b=data[idx+2];
          const lum = (0.2126*r + 0.7152*g + 0.0722*b);
          const ch = CHARSET[Math.floor((lum/255)*(CHARSET.length-1))];
          out += `<span style=\"color:rgb(${r},${g},${b})\">${ch}</span>`;
          lastGrid.push({ci:x, ri:y, ch, color:`rgb(${r},${g},${b})`});
        }
        out += "\n";
      }
      ascii.innerHTML = out;
    }

    function update(){ renderASCII(hidden.value); }

    // Tastatur-Eingabe (Desktop)
    hidden.addEventListener('keydown', (e)=>{
      if(e.key==='Enter') { e.preventDefault(); hidden.value=''; update(); }
      if(e.key==='ArrowDown'){ e.preventDefault(); triggerFall(); }
    });
    hidden.addEventListener('input', ()=>{ if(!isAnimating) update(); });

    // Immer fokussiert bleiben
    const refocus=()=> hidden.focus();
    window.addEventListener('load', ()=>{ refocus(); renderASCII(''); });
    window.addEventListener('click', refocus);
    window.addEventListener('resize', ()=>{ if(!isAnimating) renderASCII(hidden.value); });

    // --- Animation exakt aus dem ASCII-Raster + Maus-Collider ---
    function triggerFall(){
      if(isAnimating || lastGrid.length===0) return;
      isAnimating = true;
      ascii.style.display = 'none';
      anim.width  = window.innerWidth;
      anim.height = window.innerHeight;
      anim.style.display = 'block';

      const floor = anim.height - cellSize * 0.5;

      // gleiche Typografie wie im <pre>
      actx.font = `${cellSize}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace`;
      actx.textAlign = 'center';
      actx.textBaseline = 'middle';
      const charW = actx.measureText('M').width; // reale Zeichenbreite
      const charH = cellSize;
      const left  = (anim.width  - gridCols*charW) / 2;
      const top   = (anim.height - gridRows*charH) / 2;

      const parts = lastGrid.map(p=>({
        x: left + (p.ci + 0.5)*charW,
        y: top  + (p.ri + 0.5)*charH,
        vx:(Math.random()-0.5)*30,
        vy:(Math.random()-0.5)*20,
        ch:p.ch, color:p.color,
        gScale: 0.98 + Math.random()*0.04,
        air:    0.994 + Math.random()*0.004,
        rest:   0.48 + Math.random()*0.18,
        fric:   0.975 + Math.random()*0.025,
        settleV: 50 + Math.random()*25,
        maxBounces: 2 + Math.round(Math.random()),
        bounces:0, settled:false
      }));

      let last = performance.now();
      (function frame(now){
        const dt = Math.min(0.033, (now-last)/1000);
        last = now;
        actx.clearRect(0,0,anim.width,anim.height);

        let allSettled = true;
        for(const p of parts){
          if(!p.settled){
            // Integration (Slider wirkt hier live)
            p.vy += (gBase * gravityScale * p.gScale) * dt;
            p.vx *= p.air;
            p.x  += p.vx*dt;
            p.y  += p.vy*dt;

            // Kreis-Collider (Maus)
            if(mouse.active){
              const dx = p.x - mouse.x;
              const dy = p.y - mouse.y;
              const dist = Math.hypot(dx, dy);
              const R = mouse.r;
              if(dist < R){
                const nx = (dist>0? dx/dist : 1);
                const ny = (dist>0? dy/dist : 0);
                const overlap = (R - dist) + 0.5;
                p.x += nx * overlap;
                p.y += ny * overlap;
                const vn = p.vx*nx + p.vy*ny;
                const e = 0.6; // Elastizität
                if(vn < 0){
                  p.vx -= (1+e) * vn * nx;
                  p.vy -= (1+e) * vn * ny;
                }
                p.vx *= 0.98; p.vy *= 0.98;
              }
            }

            // Boden-Kollision
            if(p.y > floor){
              p.y = floor;
              p.vy = -p.vy * p.rest;
              p.vx *= p.fric;
              p.vx += (Math.random()-0.5)*24;
              p.vy += (Math.random()-0.5)*12;
              p.bounces++;
              if(Math.abs(p.vy) < p.settleV || p.bounces >= p.maxBounces){ p.vy = 0; p.settled = true; }
            }
            // Seiten-Kollisionen
            if(p.x < charW*0.5){ p.x = charW*0.5; p.vx = -p.vx * (0.55 + Math.random()*0.25); }
            if(p.x > anim.width - charW*0.5){ p.x = anim.width - charW*0.5; p.vx = -p.vx * (0.55 + Math.random()*0.25); }
          }
          if(!p.settled) allSettled = false;
          actx.fillStyle = p.color;
          actx.fillText(p.ch, p.x, p.y);
        }

        if(allSettled){
          // Reset & zurück zur ASCII-Ansicht
          isAnimating = false;
          anim.style.display = 'none';
          ascii.style.display = 'block';
          renderASCII(hidden.value);
          // Fokus zurück, damit ↓ erneut funktioniert
          refocus();
        } else {
          requestAnimationFrame(frame);
        }
      })(last);
    }
  </script>
</body>
</html>
